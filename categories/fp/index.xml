<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FP on sainth.de</title><link>https://www.sainth.de/categories/fp/</link><description>Recent content in FP on sainth.de</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â©2015-2020 Tobias Wink</copyright><lastBuildDate>Wed, 09 Mar 2016 20:15:00 +0100</lastBuildDate><atom:link href="https://www.sainth.de/categories/fp/index.xml" rel="self" type="application/rss+xml"/><item><title>A different thinking approach</title><link>https://www.sainth.de/blog/a-different-thinking-approach/</link><pubDate>Wed, 09 Mar 2016 20:15:00 +0100</pubDate><guid>https://www.sainth.de/blog/a-different-thinking-approach/</guid><description>&lt;p>Unfortunately, some time has passed again since the last post. In the &lt;a href="https://www.sainth.de/blog/brief-history-of-functional-programming/">last post&lt;/a> I wrote something about the history of functional and imperative programming. This one is now to deal with the, compared to imperative programming, different way of thinking. The source code examples shown here are based on Java for the imperative examples and Haskell for the functional examples. I will try to use only functions available in the language standard and not library functions.&lt;/p>
&lt;p>In imperative programming, one describes in detail the steps that must be performed by the computer to accomplish the task. In contrast, functional programming does not describe &lt;em>HOW&lt;/em> something is to be computed, but &lt;em>WHAT&lt;/em>. Not for nothing functional programming languages belong to the declarative programming languages.&lt;/p>
&lt;p>By the functions, just as in mathematics, the &amp;ldquo;world&amp;rdquo; is represented or defined in the actual state. In general, functional programming with its terminology and concepts is very strongly based on mathematics, which makes it not easy for not math affine humans. If one managed to understand the concepts the large advantage is that one can rely on the mathematical background of these concepts. Thus, the correctness of a program can then be proven with &amp;ldquo;relatively&amp;rdquo; little effort, at least compared to imperative programs.&lt;/p></description></item><item><title>A brief history of functional programming</title><link>https://www.sainth.de/blog/brief-history-of-functional-programming/</link><pubDate>Fri, 11 Dec 2015 18:30:00 +0100</pubDate><guid>https://www.sainth.de/blog/brief-history-of-functional-programming/</guid><description>&lt;p>Functional programming is on everyone&amp;rsquo;s lips and concepts from functional programming are being adopted everywhere in imperative languages. At the moment I am also taking a closer look at these concepts and would like to publish my findings here in the form of a series of articles. But let&amp;rsquo;s start with a short historical review.&lt;/p>
&lt;p>I have to admit that the more I researched the story, the more fascinating I found it.&lt;/p></description></item></channel></rss>