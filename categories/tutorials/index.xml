<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tutorials on sainth.de</title><link>https://www.sainth.de/categories/tutorials/</link><description>Recent content in tutorials on sainth.de</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Â©2015-2020 Tobias Wink</copyright><lastBuildDate>Mon, 01 May 2017 19:30:00 +0100</lastBuildDate><atom:link href="https://www.sainth.de/categories/tutorials/index.xml" rel="self" type="application/rss+xml"/><item><title>JWTs, a supplement to BasicAuth</title><link>https://www.sainth.de/blog/jwts-and-basic-auth/</link><pubDate>Mon, 01 May 2017 19:30:00 +0100</pubDate><guid>https://www.sainth.de/blog/jwts-and-basic-auth/</guid><description>&lt;p>Most REST APIs support BasicAuth when they require authentication and manage user data themselves. When choosing the function to protect stored passwords, it is important to find the right balance between user convenience and attacker protection. On the one hand, you want to keep adversaries at bay for as long as possible, but on the other hand, you also want to give users the shortest possible response times. All adaptive password hashing methods recommended by &lt;a href="https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Impose_infeasible_verification_on_attacker">OWASP&lt;/a> therefore offer the option of configuring the speed of the algorithm via a &lt;em>work factor&lt;/em>. In order to be able to select this &lt;em>work factor&lt;/em> as high as possible, without annoying the users unnecessarily, the use of JWTs lends itself.&lt;/p></description></item><item><title>Nexus as a binary repository for APKs</title><link>https://www.sainth.de/blog/use-nexus-as-a-binary-repository-for-apks/</link><pubDate>Tue, 17 Jan 2017 21:30:00 +0100</pubDate><guid>https://www.sainth.de/blog/use-nexus-as-a-binary-repository-for-apks/</guid><description>&lt;p>If you use &lt;a href="https://www.sonatype.com/download-oss-sonatype">Nexus OSS&lt;/a> to store your finished binary artifacts, you will of course want to do the same for your APKs. Since I&amp;rsquo;m currently working on an Android app professionally, I&amp;rsquo;ve now had the chance to gain my experience with it. Because I don&amp;rsquo;t want to make the same pitfalls again next time, I will explain it here step by step.&lt;/p>
&lt;p>My previous experiences with &lt;a href="https://gradle.org/">Gradle&lt;/a> are (fortunately) hardly worth mentioning, so first an extensive Google research was on the agenda. This soon led me to the &lt;a href="https://docs.gradle.org/current/userguide/maven_plugin.html">Maven plugin&lt;/a> for Gradle and the following configuration for &lt;code>uploadArchives&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-groovy" data-lang="groovy">apply plugin: &lt;span style="color:#e6db74">&amp;#39;maven&amp;#39;&lt;/span>
uploadArchives &lt;span style="color:#f92672">{&lt;/span>
repositories &lt;span style="color:#f92672">{&lt;/span>
mavenDeployer &lt;span style="color:#f92672">{&lt;/span>
repository&lt;span style="color:#f92672">(&lt;/span>url: &lt;span style="color:#e6db74">&amp;#34;file://localhost/tmp/myRepo/&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A corresponding call with &lt;code>gradlew clean assemble uploadArchives&lt;/code> ran successfully, but no artifacts were stored. So I then became aware of the Gradle user guide &lt;a href="https://docs.gradle.org/current/userguide/artifact_management.html">Publishing artifacts&lt;/a> and realized that the APKs must be declared so that &lt;code>uploadArchives&lt;/code> also knows what is to be uploaded.&lt;/p></description></item></channel></rss>