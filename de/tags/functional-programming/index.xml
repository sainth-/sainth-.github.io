<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>functional programming on sainth.de</title><link>https://www.sainth.de/de/tags/functional-programming/</link><description>Recent content in functional programming on sainth.de</description><generator>Hugo -- gohugo.io</generator><language>de</language><copyright>©2015-2020 Tobias Wink</copyright><lastBuildDate>Wed, 09 Mar 2016 20:15:00 +0100</lastBuildDate><atom:link href="https://www.sainth.de/de/tags/functional-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Ein anderer Denkansatz</title><link>https://www.sainth.de/de/blog/a-different-thinking-approach/</link><pubDate>Wed, 09 Mar 2016 20:15:00 +0100</pubDate><guid>https://www.sainth.de/de/blog/a-different-thinking-approach/</guid><description>&lt;p>Leider ist schon wieder einige Zeit seit dem letzten Post vergangen. Im &lt;a href="https://www.sainth.de/de/blog/brief-history-of-functional-programming/">letzten Post&lt;/a> habe ich etwas über die Historie von funktionaler und imperativer Programmierung geschrieben. Dieser hier soll sich nun mit dem, im Vergleich zur imperativen Programmierung, anderen Denkansatz beschäftigen. Die hier gezeigten Quellcode-Beispiele beruhen dabei auf Java für die imperativen Beispiele bzw. auf Haskell für die funktionalen Beispiele. Ich werde bei den gezeigten Beispielen versuchen nur im Sprachstandard vorhandene Funktionen nutzen und nicht auf Bibliotheksfunktionen zurückgreifen.&lt;/p>
&lt;p>Bei der imperativen Programmierung beschreibt man detailliert die Schritte, die vom Computer ausgeführt werden müssen, um die Aufgabe zu erfüllen. Im Gegensatz dazu wird bei der funktionalen Programmierung nicht beschrieben &lt;em>WIE&lt;/em> etwas berechnet werden soll, sondern &lt;em>WAS&lt;/em>. Nicht umsonst gehören funktionale Programmiersprachen zu den deklarativen Programmiersprachen.&lt;/p>
&lt;p>Durch die Funktionen wird, genauso wie in der Mathematik, die &amp;ldquo;Welt&amp;rdquo; im Ist-Zustand dargestellt bzw. definiert. Generell ist die funktionale Programmierung mit ihren Begrifflichkeiten und Konzepten sehr stark an der Mathematik angelehnt. Das macht es nicht matheaffinen Menschen nicht gerade leicht, birgt aber den großen Vorteil, dass man, wenn man es geschafft hat die Konzepte zu verstehen, sich auf den mathematischen Hintergrund dieser Konzepte verlassen kann. Dadurch kann dann die Richtigkeit eines Programms mit &amp;ldquo;relativ&amp;rdquo; wenig Aufwand bewiesen werden, zumindest im Vergleich zu imperativen Programmen.&lt;/p></description></item><item><title>Ein wenig Historie zur funktionalen Programmierung</title><link>https://www.sainth.de/de/blog/brief-history-of-functional-programming/</link><pubDate>Fri, 11 Dec 2015 18:30:00 +0100</pubDate><guid>https://www.sainth.de/de/blog/brief-history-of-functional-programming/</guid><description>&lt;p>Funktionale Programmierung ist in aller Munde und überall werden Konzepte aus der funktionalen Programmierung in imperative Sprachen übernommen. Auch ich bin momentan dabei, mir besagte Konzepte genauer anzusehen und möchte meine gewonnenen Erkenntnisse hier in Form einer Artikelserie veröffentlichen. Den Auftakt soll aber erst mal ein kleiner geschichtlicher Rückblick machen.&lt;/p>
&lt;p>Ich muss zugeben, dass ich die Geschichte immer faszinierender finde, je mehr ich darüber recherchiert habe.&lt;/p></description></item></channel></rss>